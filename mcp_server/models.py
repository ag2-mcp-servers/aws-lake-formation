# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T12:20:04+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, SecretStr, conint, constr


class AccessDeniedException(RootModel[Any]):
    root: Any


class AccessKeyIdString(RootModel[str]):
    root: str


class AllRowsWildcard(BaseModel):
    pass


class AlreadyExistsException(RootModel[Any]):
    root: Any


class AuditContextString(RootModel[constr(min_length=0, max_length=2048)]):
    root: constr(min_length=0, max_length=2048)


class BooleanNullable(RootModel[bool]):
    root: bool


class CancelTransactionResponse(BaseModel):
    pass


class CatalogIdString(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class CatalogResource(BaseModel):
    pass


class ComparisonOperator(Enum):
    EQ = 'EQ'
    NE = 'NE'
    LE = 'LE'
    LT = 'LT'
    GE = 'GE'
    GT = 'GT'
    CONTAINS = 'CONTAINS'
    NOT_CONTAINS = 'NOT_CONTAINS'
    BEGINS_WITH = 'BEGINS_WITH'
    IN = 'IN'
    BETWEEN = 'BETWEEN'


class ConcurrentModificationException(RootModel[Any]):
    root: Any


class CreateDataCellsFilterResponse(BaseModel):
    pass


class CreateLFTagResponse(BaseModel):
    pass


class CredentialTimeoutDurationSecondInteger(RootModel[conint(ge=900, le=43200)]):
    root: conint(ge=900, le=43200)


class DataLakePrincipalString(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class DataLakeResourceType(Enum):
    CATALOG = 'CATALOG'
    DATABASE = 'DATABASE'
    TABLE = 'TABLE'
    DATA_LOCATION = 'DATA_LOCATION'
    LF_TAG = 'LF_TAG'
    LF_TAG_POLICY = 'LF_TAG_POLICY'
    LF_TAG_POLICY_DATABASE = 'LF_TAG_POLICY_DATABASE'
    LF_TAG_POLICY_TABLE = 'LF_TAG_POLICY_TABLE'


class DateTime(RootModel[datetime]):
    root: datetime


class DeleteDataCellsFilterResponse(BaseModel):
    pass


class DeleteLFTagResponse(BaseModel):
    pass


class DeleteObjectsOnCancelResponse(BaseModel):
    pass


class DeregisterResourceResponse(BaseModel):
    pass


class DescriptionString(RootModel[constr(min_length=0, max_length=2048)]):
    root: constr(min_length=0, max_length=2048)


class ETagString(
    RootModel[constr(pattern=r'[\p{L}\p{N}\p{P}]*', min_length=1, max_length=255)]
):
    root: constr(pattern=r'[\p{L}\p{N}\p{P}]*', min_length=1, max_length=255)


class EntityNotFoundException(RootModel[Any]):
    root: Any


class ErrorMessageString(RootModel[str]):
    root: str


class ExpirationTimestamp(RootModel[datetime]):
    root: datetime


class ExpiredException(RootModel[Any]):
    root: Any


class ExtendTransactionResponse(BaseModel):
    pass


class FieldNameString(Enum):
    RESOURCE_ARN = 'RESOURCE_ARN'
    ROLE_ARN = 'ROLE_ARN'
    LAST_MODIFIED = 'LAST_MODIFIED'


class GetDataLakeSettingsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None


class GetQueryStateRequestQueryIdString(
    RootModel[constr(min_length=36, max_length=36)]
):
    root: constr(min_length=36, max_length=36)


class GetQueryStatisticsRequestQueryIdString(
    RootModel[constr(min_length=36, max_length=36)]
):
    root: constr(min_length=36, max_length=36)


class GetWorkUnitResultsRequestQueryIdString(
    RootModel[constr(min_length=36, max_length=36)]
):
    root: constr(min_length=36, max_length=36)


class GetWorkUnitResultsRequestWorkUnitIdLong(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class GetWorkUnitsRequestQueryIdString(RootModel[constr(min_length=36, max_length=36)]):
    root: constr(min_length=36, max_length=36)


class GlueEncryptionException(RootModel[Any]):
    root: Any


class GrantPermissionsResponse(BaseModel):
    pass


class IAMRoleArn(RootModel[constr(pattern=r'arn:aws:iam::[0-9]*:role/.*')]):
    root: constr(pattern=r'arn:aws:iam::[0-9]*:role/.*')


class IAMSAMLProviderArn(
    RootModel[constr(pattern=r'arn:aws:iam::[0-9]*:saml-provider/.*')]
):
    root: constr(pattern=r'arn:aws:iam::[0-9]*:saml-provider/.*')


class Identifier(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class Integer(RootModel[int]):
    root: int


class InternalServiceException(RootModel[Any]):
    root: Any


class InvalidInputException(RootModel[Any]):
    root: Any


class KeyString(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class LFTagKey(
    RootModel[
        constr(
            pattern=r'^([\p{L}\p{Z}\p{N}_.:\/=+\-@%]*)$', min_length=1, max_length=128
        )
    ]
):
    root: constr(
        pattern=r'^([\p{L}\p{Z}\p{N}_.:\/=+\-@%]*)$', min_length=1, max_length=128
    )


class LFTagValue(
    RootModel[
        constr(
            pattern=r'^([\p{L}\p{Z}\p{N}_.:\*\/=+\-@%]*)$', min_length=0, max_length=256
        )
    ]
):
    root: constr(
        pattern=r'^([\p{L}\p{Z}\p{N}_.:\*\/=+\-@%]*)$', min_length=0, max_length=256
    )


class LastModifiedTimestamp(RootModel[datetime]):
    root: datetime


class MessageString(RootModel[str]):
    root: str


class NameString(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class NullableBoolean(RootModel[bool]):
    root: bool


class NumberOfBytes(RootModel[int]):
    root: int


class NumberOfItems(RootModel[int]):
    root: int


class NumberOfMilliseconds(RootModel[int]):
    root: int


class ObjectSize(RootModel[int]):
    root: int


class OperationTimeoutException(RootModel[Any]):
    root: Any


class OptimizerType(Enum):
    COMPACTION = 'COMPACTION'
    GARBAGE_COLLECTION = 'GARBAGE_COLLECTION'
    ALL = 'ALL'


class PageSize(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class ParametersMapValue(RootModel[constr(max_length=512000)]):
    root: constr(max_length=512000)


class PartitionValueString(RootModel[constr(max_length=1024)]):
    root: constr(max_length=1024)


class PartitionValuesList(RootModel[List[PartitionValueString]]):
    root: List[PartitionValueString] = Field(..., max_length=100, min_length=1)


class Permission(Enum):
    ALL = 'ALL'
    SELECT = 'SELECT'
    ALTER = 'ALTER'
    DROP = 'DROP'
    DELETE = 'DELETE'
    INSERT = 'INSERT'
    DESCRIBE = 'DESCRIBE'
    CREATE_DATABASE = 'CREATE_DATABASE'
    CREATE_TABLE = 'CREATE_TABLE'
    DATA_LOCATION_ACCESS = 'DATA_LOCATION_ACCESS'
    CREATE_TAG = 'CREATE_TAG'
    ASSOCIATE = 'ASSOCIATE'


class PermissionList(RootModel[List[Permission]]):
    root: List[Permission]


class PermissionType(Enum):
    COLUMN_PERMISSION = 'COLUMN_PERMISSION'
    CELL_FILTER_PERMISSION = 'CELL_FILTER_PERMISSION'


class PermissionTypeList(RootModel[List[PermissionType]]):
    root: List[PermissionType] = Field(..., max_length=255, min_length=1)


class PermissionTypeMismatchException(RootModel[Any]):
    root: Any


class PlanningStatistics(BaseModel):
    EstimatedDataToScanBytes: Optional[NumberOfBytes] = None
    PlanningTimeMillis: Optional[NumberOfMilliseconds] = None
    QueueTimeMillis: Optional[NumberOfMilliseconds] = None
    WorkUnitsGeneratedCount: Optional[NumberOfItems] = None


class PredicateString(RootModel[constr(min_length=0, max_length=2048)]):
    root: constr(min_length=0, max_length=2048)


class PutDataLakeSettingsResponse(BaseModel):
    pass


class QueryIdString(RootModel[str]):
    root: str


class QueryPlanningContextDatabaseNameString(RootModel[constr(min_length=1)]):
    root: constr(min_length=1)


class QueryStateString(Enum):
    PENDING = 'PENDING'
    WORKUNITS_AVAILABLE = 'WORKUNITS_AVAILABLE'
    ERROR = 'ERROR'
    FINISHED = 'FINISHED'
    EXPIRED = 'EXPIRED'


class RAMResourceShareArn(RootModel[str]):
    root: str


class RegisterResourceResponse(BaseModel):
    pass


class ResourceArnString(RootModel[str]):
    root: str


class ResourceInfo(BaseModel):
    LastModified: Optional[LastModifiedTimestamp] = None
    ResourceArn: Optional[ResourceArnString] = None
    RoleArn: Optional[IAMRoleArn] = None
    WithFederation: Optional[NullableBoolean] = None


class ResourceInfoList(RootModel[List[ResourceInfo]]):
    root: List[ResourceInfo]


class ResourceNotReadyException(RootModel[Any]):
    root: Any


class ResourceNumberLimitExceededException(RootModel[Any]):
    root: Any


class ResourceShareList(RootModel[List[RAMResourceShareArn]]):
    root: List[RAMResourceShareArn]


class ResourceShareType(Enum):
    FOREIGN = 'FOREIGN'
    ALL = 'ALL'


class ResourceType(Enum):
    DATABASE = 'DATABASE'
    TABLE = 'TABLE'


class Result(RootModel[str]):
    root: str


class ResultStream(RootModel[str]):
    root: str


class RevokePermissionsResponse(BaseModel):
    pass


class RowFilter(BaseModel):
    AllRowsWildcard_1: Optional[AllRowsWildcard] = Field(None, alias='AllRowsWildcard')
    FilterExpression: Optional[PredicateString] = None


class SAMLAssertionString(RootModel[constr(min_length=4, max_length=100000)]):
    root: constr(min_length=4, max_length=100000)


class SearchPageSize(RootModel[conint(ge=1, le=100)]):
    root: conint(ge=1, le=100)


class SecretAccessKeyString(RootModel[str]):
    root: str


class SessionTokenString(RootModel[str]):
    root: str


class StartQueryPlanningResponse(BaseModel):
    QueryId: QueryIdString


class StatisticsNotReadyYetException(RootModel[Any]):
    root: Any


class StorageOptimizerConfigKey(RootModel[str]):
    root: str


class StorageOptimizerConfigValue(RootModel[str]):
    root: str


class String(RootModel[str]):
    root: str


class StringValue(RootModel[str]):
    root: str


class StringValueList(RootModel[List[StringValue]]):
    root: List[StringValue]


class SyntheticGetWorkUnitResultsRequestWorkUnitTokenString(RootModel[SecretStr]):
    root: SecretStr


class SyntheticStartQueryPlanningRequestQueryString(RootModel[SecretStr]):
    root: SecretStr


class TableWildcard(BaseModel):
    pass


class TagValueList(RootModel[List[LFTagValue]]):
    root: List[LFTagValue] = Field(..., max_length=50, min_length=1)


class ThrottledException(RootModel[Any]):
    root: Any


class Timestamp(RootModel[datetime]):
    root: datetime


class Token(RootModel[str]):
    root: str


class TokenString(RootModel[constr(max_length=4096)]):
    root: constr(max_length=4096)


class TransactionCanceledException(RootModel[Any]):
    root: Any


class TransactionCommitInProgressException(RootModel[Any]):
    root: Any


class TransactionCommittedException(RootModel[Any]):
    root: Any


class TransactionIdString(
    RootModel[constr(pattern=r'[\p{L}\p{N}\p{P}]*', min_length=1, max_length=255)]
):
    root: constr(pattern=r'[\p{L}\p{N}\p{P}]*', min_length=1, max_length=255)


class TransactionStatus(Enum):
    ACTIVE = 'ACTIVE'
    COMMITTED = 'COMMITTED'
    ABORTED = 'ABORTED'
    COMMIT_IN_PROGRESS = 'COMMIT_IN_PROGRESS'


class TransactionStatusFilter(Enum):
    ALL = 'ALL'
    COMPLETED = 'COMPLETED'
    ACTIVE = 'ACTIVE'
    COMMITTED = 'COMMITTED'
    ABORTED = 'ABORTED'


class TransactionType(Enum):
    READ_AND_WRITE = 'READ_AND_WRITE'
    READ_ONLY = 'READ_ONLY'


class TrueFalseString(RootModel[constr(min_length=1, max_length=5)]):
    root: constr(min_length=1, max_length=5)


class TrustedResourceOwners(RootModel[List[CatalogIdString]]):
    root: List[CatalogIdString]


class URI(RootModel[constr(min_length=1, max_length=1024)]):
    root: constr(min_length=1, max_length=1024)


class UpdateDataCellsFilterResponse(BaseModel):
    pass


class UpdateLFTagRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    TagKey: LFTagKey
    TagValuesToAdd: Optional[TagValueList] = None
    TagValuesToDelete: Optional[TagValueList] = None


class UpdateLFTagResponse(BaseModel):
    pass


class UpdateResourceRequest(BaseModel):
    ResourceArn: ResourceArnString
    RoleArn: IAMRoleArn
    WithFederation: Optional[NullableBoolean] = None


class UpdateResourceResponse(BaseModel):
    pass


class UpdateTableObjectsResponse(BaseModel):
    pass


class UpdateTableStorageOptimizerResponse(BaseModel):
    Result_1: Optional[Result] = Field(None, alias='Result')


class ValueString(RootModel[str]):
    root: str


class ValueStringList(RootModel[List[ValueString]]):
    root: List[ValueString] = Field(..., min_length=1)


class VersionString(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class VirtualObject(BaseModel):
    ETag: Optional[ETagString] = None
    Uri: URI


class VirtualObjectList(RootModel[List[VirtualObject]]):
    root: List[VirtualObject] = Field(..., max_length=100, min_length=1)


class WorkUnitIdLong(RootModel[int]):
    root: int


class WorkUnitTokenString(RootModel[str]):
    root: str


class WorkUnitsNotReadyYetException(RootModel[Any]):
    root: Any


class AssumeDecoratedRoleWithSAMLPostRequest(BaseModel):
    DurationSeconds: Optional[conint(ge=900, le=43200)] = Field(
        None,
        description='The time period, between 900 and 43,200 seconds, for the timeout of the temporary credentials.',
    )
    PrincipalArn: constr(pattern=r'arn:aws:iam::[0-9]*:saml-provider/.*') = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the SAML provider in IAM that describes the IdP.',
    )
    RoleArn: constr(pattern=r'arn:aws:iam::[0-9]*:role/.*') = Field(
        ...,
        description='The role that represents an IAM principal whose scope down policy allows it to call credential vending APIs such as <code>GetTemporaryTableCredentials</code>. The caller must also have iam:PassRole permission on this role. ',
    )
    SAMLAssertion: constr(min_length=4, max_length=100000) = Field(
        ...,
        description='A SAML assertion consisting of an assertion statement for the user who needs temporary credentials. This must match the SAML assertion that was issued to IAM. This must be Base64 encoded.',
    )


class CancelTransactionPostRequest(BaseModel):
    TransactionId: constr(
        pattern=r'[\p{L}\p{N}\p{P}]*', min_length=1, max_length=255
    ) = Field(..., description='The transaction to cancel.')


class CommitTransactionPostRequest(BaseModel):
    TransactionId: constr(
        pattern=r'[\p{L}\p{N}\p{P}]*', min_length=1, max_length=255
    ) = Field(..., description='The transaction to commit.')


class CreateLFTagPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    TagKey: constr(
        pattern=r'^([\p{L}\p{Z}\p{N}_.:\/=+\-@%]*)$', min_length=1, max_length=128
    ) = Field(..., description='The key-name for the LF-tag.')
    TagValues: List[LFTagValue] = Field(
        ...,
        description='A list of possible values an attribute can take.',
        max_length=50,
        min_length=1,
    )


class DeleteDataCellsFilterPostRequest(BaseModel):
    DatabaseName: Optional[constr(min_length=1, max_length=255)] = Field(
        None, description='A database in the Glue Data Catalog.'
    )
    Name: Optional[constr(min_length=1, max_length=255)] = Field(
        None, description='The name given by the user to the data filter cell.'
    )
    TableCatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None, description='The ID of the catalog to which the table belongs.'
    )
    TableName: Optional[constr(min_length=1, max_length=255)] = Field(
        None, description='A table in the database.'
    )


class DeleteLFTagPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    TagKey: constr(
        pattern=r'^([\p{L}\p{Z}\p{N}_.:\/=+\-@%]*)$', min_length=1, max_length=128
    ) = Field(..., description='The key-name for the LF-tag to delete.')


class DeleteObjectsOnCancelPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The Glue data catalog that contains the governed table. Defaults to the current account ID.',
    )
    DatabaseName: constr(min_length=1, max_length=255) = Field(
        ..., description='The database that contains the governed table.'
    )
    Objects: List[VirtualObject] = Field(
        ...,
        description='A list of VirtualObject structures, which indicates the Amazon S3 objects to be deleted if the transaction cancels.',
        max_length=100,
        min_length=1,
    )
    TableName: constr(min_length=1, max_length=255) = Field(
        ..., description='The name of the governed table.'
    )
    TransactionId: constr(
        pattern=r'[\p{L}\p{N}\p{P}]*', min_length=1, max_length=255
    ) = Field(..., description='ID of the transaction that the writes occur in.')


class DeregisterResourcePostRequest(BaseModel):
    ResourceArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the resource that you want to deregister.',
    )


class DescribeResourcePostRequest(BaseModel):
    ResourceArn: str = Field(..., description='The resource ARN.')


class DescribeTransactionPostRequest(BaseModel):
    TransactionId: constr(
        pattern=r'[\p{L}\p{N}\p{P}]*', min_length=1, max_length=255
    ) = Field(..., description='The transaction for which to return status.')


class ExtendTransactionPostRequest(BaseModel):
    TransactionId: Optional[
        constr(pattern=r'[\p{L}\p{N}\p{P}]*', min_length=1, max_length=255)
    ] = Field(None, description='The transaction to extend.')


class GetDataCellsFilterPostRequest(BaseModel):
    DatabaseName: constr(min_length=1, max_length=255) = Field(
        ..., description='A database in the Glue Data Catalog.'
    )
    Name: constr(min_length=1, max_length=255) = Field(
        ..., description='The name given by the user to the data filter cell.'
    )
    TableCatalogId: constr(min_length=1, max_length=255) = Field(
        ..., description='The ID of the catalog to which the table belongs.'
    )
    TableName: constr(min_length=1, max_length=255) = Field(
        ..., description='A table in the database.'
    )


class GetDataLakeSettingsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )


class GetEffectivePermissionsForPathPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    MaxResults: Optional[conint(ge=1, le=1000)] = Field(
        None, description='The maximum number of results to return.'
    )
    NextToken: Optional[str] = Field(
        None,
        description='A continuation token, if this is not the first call to retrieve this list.',
    )
    ResourceArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the resource for which you want to get permissions.',
    )


class GetLFTagPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    TagKey: constr(
        pattern=r'^([\p{L}\p{Z}\p{N}_.:\/=+\-@%]*)$', min_length=1, max_length=128
    ) = Field(..., description='The key-name for the LF-tag.')


class GetQueryStatePostRequest(BaseModel):
    QueryId: constr(min_length=36, max_length=36) = Field(
        ..., description='The ID of the plan query operation.'
    )


class GetQueryStatisticsPostRequest(BaseModel):
    QueryId: constr(min_length=36, max_length=36) = Field(
        ..., description='The ID of the plan query operation.'
    )


class GetTableObjectsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The catalog containing the governed table. Defaults to the callerâ€™s account.',
    )
    DatabaseName: constr(min_length=1, max_length=255) = Field(
        ..., description='The database containing the governed table.'
    )
    MaxResults: Optional[conint(ge=1, le=1000)] = Field(
        None, description='Specifies how many values to return in a page.'
    )
    NextToken: Optional[constr(max_length=4096)] = Field(
        None,
        description='A continuation token if this is not the first call to retrieve these objects.',
    )
    PartitionPredicate: Optional[constr(min_length=0, max_length=2048)] = Field(
        None,
        description='<p>A predicate to filter the objects returned based on the partition keys defined in the governed table.</p> <ul> <li> <p>The comparison operators supported are: =, &gt;, &lt;, &gt;=, &lt;=</p> </li> <li> <p>The logical operators supported are: AND</p> </li> <li> <p>The data types supported are integer, long, date(yyyy-MM-dd), timestamp(yyyy-MM-dd HH:mm:ssXXX or yyyy-MM-dd HH:mm:ss"), string and decimal.</p> </li> </ul>',
    )
    QueryAsOfTime: Optional[datetime] = Field(
        None,
        description='The time as of when to read the governed table contents. If not set, the most recent transaction commit time is used. Cannot be specified along with <code>TransactionId</code>.',
    )
    TableName: constr(min_length=1, max_length=255) = Field(
        ..., description='The governed table for which to retrieve objects.'
    )
    TransactionId: Optional[
        constr(pattern=r'[\p{L}\p{N}\p{P}]*', min_length=1, max_length=255)
    ] = Field(
        None,
        description='The transaction ID at which to read the governed table contents. If this transaction has aborted, an error is returned. If not set, defaults to the most recent committed transaction. Cannot be specified along with <code>QueryAsOfTime</code>.',
    )


class AuditContext(BaseModel):
    AdditionalAuditContext: Optional[AuditContextString] = None


class Partition(BaseModel):
    Values: Optional[ValueStringList] = None


class GetTemporaryGluePartitionCredentialsPostRequest(BaseModel):
    AuditContext_1: Optional[AuditContext] = Field(
        None,
        alias='AuditContext',
        description='A structure used to include auditing information on the privileged API. ',
    )
    DurationSeconds: Optional[conint(ge=900, le=43200)] = Field(
        None,
        description='The time period, between 900 and 21,600 seconds, for the timeout of the temporary credentials.',
    )
    Partition_1: Partition = Field(
        ...,
        alias='Partition',
        description='Contains a list of values defining partitions.',
    )
    Permissions: Optional[List[Permission]] = Field(
        None,
        description='Filters the request based on the user having been granted a list of specified permissions on the requested resource(s).',
    )
    SupportedPermissionTypes: List[PermissionType] = Field(
        ...,
        description='A list of supported permission types for the partition. Valid values are <code>COLUMN_PERMISSION</code> and <code>CELL_FILTER_PERMISSION</code>.',
        max_length=255,
        min_length=1,
    )
    TableArn: str = Field(..., description="The ARN of the partitions' table.")


class GetTemporaryGlueTableCredentialsPostRequest(BaseModel):
    AuditContext_1: Optional[AuditContext] = Field(
        None,
        alias='AuditContext',
        description='A structure used to include auditing information on the privileged API. ',
    )
    DurationSeconds: Optional[conint(ge=900, le=43200)] = Field(
        None,
        description='The time period, between 900 and 21,600 seconds, for the timeout of the temporary credentials.',
    )
    Permissions: Optional[List[Permission]] = Field(
        None,
        description='Filters the request based on the user having been granted a list of specified permissions on the requested resource(s).',
    )
    SupportedPermissionTypes: List[PermissionType] = Field(
        ...,
        description='A list of supported permission types for the table. Valid values are <code>COLUMN_PERMISSION</code> and <code>CELL_FILTER_PERMISSION</code>.',
        max_length=255,
        min_length=1,
    )
    TableArn: str = Field(
        ...,
        description='The ARN identifying a table in the Data Catalog for the temporary credentials request.',
    )


class GetWorkUnitResultsPostRequest(BaseModel):
    QueryId: constr(min_length=36, max_length=36) = Field(
        ..., description='The ID of the plan query operation for which to get results.'
    )
    WorkUnitId: conint(ge=0) = Field(
        ...,
        description='The work unit ID for which to get results. Value generated by enumerating <code>WorkUnitIdMin</code> to <code>WorkUnitIdMax</code> (inclusive) from the <code>WorkUnitRange</code> in the output of <code>GetWorkUnits</code>.',
    )
    WorkUnitToken: SecretStr = Field(
        ...,
        description='A work token used to query the execution service. Token output from <code>GetWorkUnits</code>.',
    )


class GetWorkUnitsPostRequest(BaseModel):
    NextToken: Optional[str] = Field(
        None, description='A continuation token, if this is a continuation call.'
    )
    PageSize: Optional[int] = Field(
        None,
        description="The size of each page to get in the Amazon Web Services service call. This does not affect the number of items returned in the command's output. Setting a smaller page size results in more calls to the Amazon Web Services service, retrieving fewer items in each call. This can help prevent the Amazon Web Services service calls from timing out.",
    )
    QueryId: constr(min_length=36, max_length=36) = Field(
        ..., description='The ID of the plan query operation.'
    )


class Principal(BaseModel):
    DataLakePrincipalIdentifier: Optional[DataLakePrincipalString] = None


class Table(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    DatabaseName: Optional[NameString] = None
    Name: Optional[NameString] = None
    TableWildcard_1: Optional[TableWildcard] = Field(None, alias='TableWildcard')


class ListDataCellsFilterPostRequest(BaseModel):
    MaxResults: Optional[conint(ge=1, le=1000)] = Field(
        None, description='The maximum size of the response.'
    )
    NextToken: Optional[str] = Field(
        None, description='A continuation token, if this is a continuation call.'
    )
    Table_1: Optional[Table] = Field(
        None,
        alias='Table',
        description='A structure for the table object. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal. ',
    )


class ListLFTagsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    MaxResults: Optional[conint(ge=1, le=1000)] = Field(
        None, description='The maximum number of results to return.'
    )
    NextToken: Optional[str] = Field(
        None,
        description='A continuation token, if this is not the first call to retrieve this list.',
    )
    ResourceShareType_1: Optional[ResourceShareType] = Field(
        None,
        alias='ResourceShareType',
        description='If resource share type is <code>ALL</code>, returns both in-account LF-tags and shared LF-tags that the requester has permission to view. If resource share type is <code>FOREIGN</code>, returns all share LF-tags that the requester can view. If no resource share type is passed, lists LF-tags in the given catalog ID that the requester has permission to view.',
    )


class ResourceType1(Enum):
    CATALOG = 'CATALOG'
    DATABASE = 'DATABASE'
    TABLE = 'TABLE'
    DATA_LOCATION = 'DATA_LOCATION'
    LF_TAG = 'LF_TAG'
    LF_TAG_POLICY = 'LF_TAG_POLICY'
    LF_TAG_POLICY_DATABASE = 'LF_TAG_POLICY_DATABASE'
    LF_TAG_POLICY_TABLE = 'LF_TAG_POLICY_TABLE'


class StorageOptimizerType(Enum):
    COMPACTION = 'COMPACTION'
    GARBAGE_COLLECTION = 'GARBAGE_COLLECTION'
    ALL = 'ALL'


class ListTableStorageOptimizersPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None, description='The Catalog ID of the table.'
    )
    DatabaseName: constr(min_length=1, max_length=255) = Field(
        ..., description='Name of the database where the table is present.'
    )
    MaxResults: Optional[conint(ge=1, le=1000)] = Field(
        None, description='The number of storage optimizers to return on each call.'
    )
    NextToken: Optional[str] = Field(
        None, description='A continuation token, if this is a continuation call.'
    )
    StorageOptimizerType_1: Optional[StorageOptimizerType] = Field(
        None,
        alias='StorageOptimizerType',
        description='The specific type of storage optimizers to list. The supported value is <code>compaction</code>.',
    )
    TableName: constr(min_length=1, max_length=255) = Field(
        ..., description='Name of the table.'
    )


class StatusFilter(Enum):
    ALL = 'ALL'
    COMPLETED = 'COMPLETED'
    ACTIVE = 'ACTIVE'
    COMMITTED = 'COMMITTED'
    ABORTED = 'ABORTED'


class ListTransactionsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The catalog for which to list transactions. Defaults to the account ID of the caller.',
    )
    MaxResults: Optional[conint(ge=1, le=1000)] = Field(
        None,
        description='The maximum number of transactions to return in a single call.',
    )
    NextToken: Optional[constr(max_length=4096)] = Field(
        None,
        description='A continuation token if this is not the first call to retrieve transactions.',
    )
    StatusFilter_1: Optional[StatusFilter] = Field(
        None,
        alias='StatusFilter',
        description=' A filter indicating the status of transactions to return. Options are ALL | COMPLETED | COMMITTED | ABORTED | ACTIVE. The default is <code>ALL</code>.',
    )


class RegisterResourcePostRequest(BaseModel):
    ResourceArn: str = Field(
        ...,
        description='The Amazon Resource Name (ARN) of the resource that you want to register.',
    )
    RoleArn: Optional[constr(pattern=r'arn:aws:iam::[0-9]*:role/.*')] = Field(
        None, description='The identifier for the role that registers the resource.'
    )
    UseServiceLinkedRole: Optional[bool] = Field(
        None,
        description='<p>Designates an Identity and Access Management (IAM) service-linked role by registering this role with the Data Catalog. A service-linked role is a unique type of IAM role that is linked directly to Lake Formation.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/lake-formation/latest/dg/service-linked-roles.html">Using Service-Linked Roles for Lake Formation</a>.</p>',
    )
    WithFederation: Optional[bool] = Field(
        None, description='Whether or not the resource is a federated resource.'
    )


class StartTransactionPostRequest(BaseModel):
    TransactionType_1: Optional[TransactionType] = Field(
        None,
        alias='TransactionType',
        description='Indicates whether this transaction should be read only or read and write. Writes made using a read-only transaction ID will be rejected. Read-only transactions do not need to be committed. ',
    )


class UpdateLFTagPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    TagKey: constr(
        pattern=r'^([\p{L}\p{Z}\p{N}_.:\/=+\-@%]*)$', min_length=1, max_length=128
    ) = Field(
        ...,
        description='The key-name for the LF-tag for which to add or delete values.',
    )
    TagValuesToAdd: Optional[List[LFTagValue]] = Field(
        None,
        description='A list of LF-tag values to add from the LF-tag.',
        max_length=50,
        min_length=1,
    )
    TagValuesToDelete: Optional[List[LFTagValue]] = Field(
        None,
        description='A list of LF-tag values to delete from the LF-tag.',
        max_length=50,
        min_length=1,
    )


class UpdateResourcePostRequest(BaseModel):
    ResourceArn: str = Field(..., description='The resource ARN.')
    RoleArn: constr(pattern=r'arn:aws:iam::[0-9]*:role/.*') = Field(
        ...,
        description='The new role to use for the given resource registered in Lake Formation.',
    )
    WithFederation: Optional[bool] = Field(
        None, description='Whether or not the resource is a federated resource.'
    )


class AddObjectInput(BaseModel):
    ETag: ETagString
    PartitionValues: Optional[PartitionValuesList] = None
    Size: ObjectSize
    Uri: URI


class AssumeDecoratedRoleWithSAMLRequest(BaseModel):
    DurationSeconds: Optional[CredentialTimeoutDurationSecondInteger] = None
    PrincipalArn: IAMSAMLProviderArn
    RoleArn: IAMRoleArn
    SAMLAssertion: SAMLAssertionString


class AssumeDecoratedRoleWithSAMLResponse(BaseModel):
    AccessKeyId: Optional[AccessKeyIdString] = None
    Expiration: Optional[ExpirationTimestamp] = None
    SecretAccessKey: Optional[SecretAccessKeyString] = None
    SessionToken: Optional[SessionTokenString] = None


class AuthorizedSessionTagValueList(RootModel[List[NameString]]):
    root: List[NameString]


class CancelTransactionRequest(BaseModel):
    TransactionId: TransactionIdString


class ColumnNames(RootModel[List[NameString]]):
    root: List[NameString]


class ColumnWildcard(BaseModel):
    ExcludedColumnNames: Optional[ColumnNames] = None


class CommitTransactionRequest(BaseModel):
    TransactionId: TransactionIdString


class CommitTransactionResponse(BaseModel):
    TransactionStatus_1: Optional[TransactionStatus] = Field(
        None, alias='TransactionStatus'
    )


class CreateLFTagRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    TagKey: LFTagKey
    TagValues: TagValueList


class DataCellsFilter(BaseModel):
    ColumnNames_1: Optional[ColumnNames] = Field(None, alias='ColumnNames')
    ColumnWildcard_1: Optional[ColumnWildcard] = Field(None, alias='ColumnWildcard')
    DatabaseName: NameString
    Name: NameString
    RowFilter_1: Optional[RowFilter] = Field(None, alias='RowFilter')
    TableCatalogId: CatalogIdString
    TableName: NameString
    VersionId: Optional[VersionString] = None


class DataCellsFilterList(RootModel[List[DataCellsFilter]]):
    root: List[DataCellsFilter]


class DataCellsFilterResource(BaseModel):
    DatabaseName: Optional[NameString] = None
    Name: Optional[NameString] = None
    TableCatalogId: Optional[CatalogIdString] = None
    TableName: Optional[NameString] = None


class DataLakePrincipal(BaseModel):
    DataLakePrincipalIdentifier: Optional[DataLakePrincipalString] = None


class DataLakePrincipalList(RootModel[List[DataLakePrincipal]]):
    root: List[DataLakePrincipal] = Field(..., max_length=30, min_length=0)


class DataLocationResource(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    ResourceArn: ResourceArnString


class DatabaseResource(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    Name: NameString


class DeleteDataCellsFilterRequest(BaseModel):
    DatabaseName: Optional[NameString] = None
    Name: Optional[NameString] = None
    TableCatalogId: Optional[CatalogIdString] = None
    TableName: Optional[NameString] = None


class DeleteLFTagRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    TagKey: LFTagKey


class DeleteObjectInput(BaseModel):
    ETag: Optional[ETagString] = None
    PartitionValues: Optional[PartitionValuesList] = None
    Uri: URI


class DeleteObjectsOnCancelRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    DatabaseName: NameString
    Objects: VirtualObjectList
    TableName: NameString
    TransactionId: TransactionIdString


class DeregisterResourceRequest(BaseModel):
    ResourceArn: ResourceArnString


class DescribeResourceRequest(BaseModel):
    ResourceArn: ResourceArnString


class DescribeResourceResponse(BaseModel):
    ResourceInfo_1: Optional[ResourceInfo] = Field(None, alias='ResourceInfo')


class DescribeTransactionRequest(BaseModel):
    TransactionId: TransactionIdString


class DetailsMap(BaseModel):
    ResourceShare: Optional[ResourceShareList] = None


class ErrorDetail(BaseModel):
    ErrorCode: Optional[NameString] = None
    ErrorMessage: Optional[DescriptionString] = None


class ExecutionStatistics(BaseModel):
    AverageExecutionTimeMillis: Optional[NumberOfMilliseconds] = None
    DataScannedBytes: Optional[NumberOfBytes] = None
    WorkUnitsExecutedCount: Optional[NumberOfItems] = None


class ExtendTransactionRequest(BaseModel):
    TransactionId: Optional[TransactionIdString] = None


class FilterCondition(BaseModel):
    ComparisonOperator_1: Optional[ComparisonOperator] = Field(
        None, alias='ComparisonOperator'
    )
    Field: Optional[FieldNameString] = None
    StringValueList_1: Optional[StringValueList] = Field(None, alias='StringValueList')


class FilterConditionList(RootModel[List[FilterCondition]]):
    root: List[FilterCondition] = Field(..., max_length=20, min_length=1)


class GetDataCellsFilterRequest(BaseModel):
    DatabaseName: NameString
    Name: NameString
    TableCatalogId: CatalogIdString
    TableName: NameString


class GetDataCellsFilterResponse(BaseModel):
    DataCellsFilter_1: Optional[DataCellsFilter] = Field(None, alias='DataCellsFilter')


class GetEffectivePermissionsForPathRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    MaxResults: Optional[PageSize] = None
    NextToken: Optional[Token] = None
    ResourceArn: ResourceArnString


class GetLFTagRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    TagKey: LFTagKey


class GetLFTagResponse(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    TagKey: Optional[LFTagKey] = None
    TagValues: Optional[TagValueList] = None


class GetQueryStateRequest(BaseModel):
    QueryId: GetQueryStateRequestQueryIdString


class GetQueryStateResponse(BaseModel):
    Error: Optional[ErrorMessageString] = None
    State: QueryStateString


class GetQueryStatisticsRequest(BaseModel):
    QueryId: GetQueryStatisticsRequestQueryIdString


class GetQueryStatisticsResponse(BaseModel):
    ExecutionStatistics_1: Optional[ExecutionStatistics] = Field(
        None, alias='ExecutionStatistics'
    )
    PlanningStatistics_1: Optional[PlanningStatistics] = Field(
        None, alias='PlanningStatistics'
    )
    QuerySubmissionTime: Optional[DateTime] = None


class GetTableObjectsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    DatabaseName: NameString
    MaxResults: Optional[PageSize] = None
    NextToken: Optional[TokenString] = None
    PartitionPredicate: Optional[PredicateString] = None
    QueryAsOfTime: Optional[Timestamp] = None
    TableName: NameString
    TransactionId: Optional[TransactionIdString] = None


class GetTemporaryGluePartitionCredentialsResponse(BaseModel):
    AccessKeyId: Optional[AccessKeyIdString] = None
    Expiration: Optional[ExpirationTimestamp] = None
    SecretAccessKey: Optional[SecretAccessKeyString] = None
    SessionToken: Optional[SessionTokenString] = None


class GetTemporaryGlueTableCredentialsRequest(BaseModel):
    AuditContext_1: Optional[AuditContext] = Field(None, alias='AuditContext')
    DurationSeconds: Optional[CredentialTimeoutDurationSecondInteger] = None
    Permissions: Optional[PermissionList] = None
    SupportedPermissionTypes: PermissionTypeList
    TableArn: ResourceArnString


class GetTemporaryGlueTableCredentialsResponse(BaseModel):
    AccessKeyId: Optional[AccessKeyIdString] = None
    Expiration: Optional[ExpirationTimestamp] = None
    SecretAccessKey: Optional[SecretAccessKeyString] = None
    SessionToken: Optional[SessionTokenString] = None


class GetWorkUnitResultsRequest(BaseModel):
    QueryId: GetWorkUnitResultsRequestQueryIdString
    WorkUnitId: GetWorkUnitResultsRequestWorkUnitIdLong
    WorkUnitToken: SyntheticGetWorkUnitResultsRequestWorkUnitTokenString


class GetWorkUnitResultsResponse(BaseModel):
    ResultStream_1: Optional[ResultStream] = Field(None, alias='ResultStream')


class GetWorkUnitsRequest(BaseModel):
    NextToken: Optional[Token] = None
    PageSize: Optional[Integer] = None
    QueryId: GetWorkUnitsRequestQueryIdString


class LFTag(BaseModel):
    TagKey: LFTagKey
    TagValues: TagValueList


class LFTagKeyResource(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    TagKey: NameString
    TagValues: TagValueList


class LFTagPair(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    TagKey: LFTagKey
    TagValues: TagValueList


class LFTagsList(RootModel[List[LFTagPair]]):
    root: List[LFTagPair] = Field(..., max_length=50, min_length=1)


class ListDataCellsFilterResponse(BaseModel):
    DataCellsFilters: Optional[DataCellsFilterList] = None
    NextToken: Optional[Token] = None


class ListLFTagsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    MaxResults: Optional[PageSize] = None
    NextToken: Optional[Token] = None
    ResourceShareType_1: Optional[ResourceShareType] = Field(
        None, alias='ResourceShareType'
    )


class ListLFTagsResponse(BaseModel):
    LFTags: Optional[LFTagsList] = None
    NextToken: Optional[Token] = None


class ListResourcesRequest(BaseModel):
    FilterConditionList_1: Optional[FilterConditionList] = Field(
        None, alias='FilterConditionList'
    )
    MaxResults: Optional[PageSize] = None
    NextToken: Optional[Token] = None


class ListResourcesResponse(BaseModel):
    NextToken: Optional[Token] = None
    ResourceInfoList_1: Optional[ResourceInfoList] = Field(
        None, alias='ResourceInfoList'
    )


class ListTableStorageOptimizersRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    DatabaseName: NameString
    MaxResults: Optional[PageSize] = None
    NextToken: Optional[Token] = None
    StorageOptimizerType: Optional[OptimizerType] = None
    TableName: NameString


class ListTransactionsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    MaxResults: Optional[PageSize] = None
    NextToken: Optional[TokenString] = None
    StatusFilter: Optional[TransactionStatusFilter] = None


class ParametersMap(RootModel[Optional[Dict[str, ParametersMapValue]]]):
    root: Optional[Dict[str, ParametersMapValue]] = None


class PartitionValueList(BaseModel):
    Values: ValueStringList


class PrincipalPermissions(BaseModel):
    Permissions: Optional[PermissionList] = None
    Principal: Optional[DataLakePrincipal] = None


class PrincipalPermissionsList(RootModel[List[PrincipalPermissions]]):
    root: List[PrincipalPermissions]


class QueryParameterMap(RootModel[Optional[Dict[str, String]]]):
    root: Optional[Dict[str, String]] = None


class QueryPlanningContext(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    DatabaseName: QueryPlanningContextDatabaseNameString
    QueryAsOfTime: Optional[Timestamp] = None
    QueryParameters: Optional[QueryParameterMap] = None
    TransactionId: Optional[TransactionIdString] = None


class RegisterResourceRequest(BaseModel):
    ResourceArn: ResourceArnString
    RoleArn: Optional[IAMRoleArn] = None
    UseServiceLinkedRole: Optional[NullableBoolean] = None
    WithFederation: Optional[NullableBoolean] = None


class StartQueryPlanningRequest(BaseModel):
    QueryPlanningContext_1: QueryPlanningContext = Field(
        ..., alias='QueryPlanningContext'
    )
    QueryString: SyntheticStartQueryPlanningRequestQueryString


class StartTransactionRequest(BaseModel):
    TransactionType_1: Optional[TransactionType] = Field(None, alias='TransactionType')


class StartTransactionResponse(BaseModel):
    TransactionId: Optional[TransactionIdString] = None


class StorageOptimizerConfig(
    RootModel[Optional[Dict[str, StorageOptimizerConfigValue]]]
):
    root: Optional[Dict[str, StorageOptimizerConfigValue]] = None


class StorageOptimizerConfigMap(RootModel[Optional[Dict[str, StorageOptimizerConfig]]]):
    root: Optional[Dict[str, StorageOptimizerConfig]] = None


class TableObject(BaseModel):
    ETag: Optional[ETagString] = None
    Size: Optional[ObjectSize] = None
    Uri: Optional[URI] = None


class TableObjectList(RootModel[List[TableObject]]):
    root: List[TableObject]


class TableResource(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    DatabaseName: NameString
    Name: Optional[NameString] = None
    TableWildcard_1: Optional[TableWildcard] = Field(None, alias='TableWildcard')


class TableWithColumnsResource(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    ColumnNames_1: Optional[ColumnNames] = Field(None, alias='ColumnNames')
    ColumnWildcard_1: Optional[ColumnWildcard] = Field(None, alias='ColumnWildcard')
    DatabaseName: NameString
    Name: NameString


class TaggedDatabase(BaseModel):
    Database: Optional[DatabaseResource] = None
    LFTags: Optional[LFTagsList] = None


class TransactionDescription(BaseModel):
    TransactionEndTime: Optional[Timestamp] = None
    TransactionId: Optional[TransactionIdString] = None
    TransactionStartTime: Optional[Timestamp] = None
    TransactionStatus_1: Optional[TransactionStatus] = Field(
        None, alias='TransactionStatus'
    )


class TransactionDescriptionList(RootModel[List[TransactionDescription]]):
    root: List[TransactionDescription]


class UpdateDataCellsFilterRequest(BaseModel):
    TableData: DataCellsFilter


class UpdateTableStorageOptimizerRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    DatabaseName: NameString
    StorageOptimizerConfig: StorageOptimizerConfigMap
    TableName: NameString


class WorkUnitRange(BaseModel):
    WorkUnitIdMax: WorkUnitIdLong
    WorkUnitIdMin: WorkUnitIdLong
    WorkUnitToken: WorkUnitTokenString


class WorkUnitRangeList(RootModel[List[WorkUnitRange]]):
    root: List[WorkUnitRange]


class WriteOperation(BaseModel):
    AddObject: Optional[AddObjectInput] = None
    DeleteObject: Optional[DeleteObjectInput] = None


class WriteOperationList(RootModel[List[WriteOperation]]):
    root: List[WriteOperation] = Field(..., max_length=100, min_length=1)


class TableData(BaseModel):
    ColumnNames_1: Optional[ColumnNames] = Field(None, alias='ColumnNames')
    ColumnWildcard_1: Optional[ColumnWildcard] = Field(None, alias='ColumnWildcard')
    DatabaseName: Optional[NameString] = None
    Name: Optional[NameString] = None
    RowFilter_1: Optional[RowFilter] = Field(None, alias='RowFilter')
    TableCatalogId: Optional[CatalogIdString] = None
    TableName: Optional[NameString] = None
    VersionId: Optional[VersionString] = None


class CreateDataCellsFilterPostRequest(BaseModel):
    TableData_1: TableData = Field(
        ...,
        alias='TableData',
        description='A structure that describes certain columns on certain rows.',
    )


class ListResourcesPostRequest(BaseModel):
    FilterConditionList: Optional[List[FilterCondition]] = Field(
        None,
        description='Any applicable row-level and/or column-level filtering conditions for the resources.',
        max_length=20,
        min_length=1,
    )
    MaxResults: Optional[conint(ge=1, le=1000)] = Field(
        None, description='The maximum number of resource results.'
    )
    NextToken: Optional[str] = Field(
        None,
        description='A continuation token, if this is not the first call to retrieve these resources.',
    )


class DataLakeSettings(BaseModel):
    AllowExternalDataFiltering: Optional[NullableBoolean] = None
    AuthorizedSessionTagValueList_1: Optional[AuthorizedSessionTagValueList] = Field(
        None, alias='AuthorizedSessionTagValueList'
    )
    CreateDatabaseDefaultPermissions: Optional[PrincipalPermissionsList] = None
    CreateTableDefaultPermissions: Optional[PrincipalPermissionsList] = None
    DataLakeAdmins: Optional[DataLakePrincipalList] = None
    ExternalDataFilteringAllowList: Optional[DataLakePrincipalList] = None
    Parameters: Optional[ParametersMap] = None
    TrustedResourceOwners_1: Optional[TrustedResourceOwners] = Field(
        None, alias='TrustedResourceOwners'
    )


class PutDataLakeSettingsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    DataLakeSettings_1: DataLakeSettings = Field(
        ...,
        alias='DataLakeSettings',
        description='A structure representing a list of Lake Formation principals designated as data lake administrators and lists of principal permission entries for default create database and default create table permissions.',
    )


class SearchDatabasesByLFTagsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    Expression: List[LFTag] = Field(
        ...,
        description='A list of conditions (<code>LFTag</code> structures) to search for in database resources.',
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return.'
    )
    NextToken: Optional[str] = Field(
        None,
        description='A continuation token, if this is not the first call to retrieve this list.',
    )


class SearchTablesByLFTagsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    Expression: List[LFTag] = Field(
        ...,
        description='A list of conditions (<code>LFTag</code> structures) to search for in table resources.',
    )
    MaxResults: Optional[conint(ge=1, le=100)] = Field(
        None, description='The maximum number of results to return.'
    )
    NextToken: Optional[str] = Field(
        None,
        description='A continuation token, if this is not the first call to retrieve this list.',
    )


class QueryPlanningContext1(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    DatabaseName: Optional[QueryPlanningContextDatabaseNameString] = None
    QueryAsOfTime: Optional[Timestamp] = None
    QueryParameters: Optional[QueryParameterMap] = None
    TransactionId: Optional[TransactionIdString] = None


class StartQueryPlanningPostRequest(BaseModel):
    QueryPlanningContext: QueryPlanningContext1 = Field(
        ..., description='A structure containing information about the query plan.'
    )
    QueryString: SecretStr = Field(
        ...,
        description='A PartiQL query statement used as an input to the planner service.',
    )


class UpdateDataCellsFilterPostRequest(BaseModel):
    TableData_1: TableData = Field(
        ...,
        alias='TableData',
        description='A structure that describes certain columns on certain rows.',
    )


class UpdateTableObjectsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The catalog containing the governed table to update. Defaults to the callerâ€™s account ID.',
    )
    DatabaseName: constr(min_length=1, max_length=255) = Field(
        ..., description='The database containing the governed table to update.'
    )
    TableName: constr(min_length=1, max_length=255) = Field(
        ..., description='The governed table to update.'
    )
    TransactionId: Optional[
        constr(pattern=r'[\p{L}\p{N}\p{P}]*', min_length=1, max_length=255)
    ] = Field(None, description='The transaction at which to do the write.')
    WriteOperations: List[WriteOperation] = Field(
        ...,
        description='A list of <code>WriteOperation</code> objects that define an object to add to or delete from the manifest for a governed table.',
        max_length=100,
        min_length=1,
    )


class UpdateTableStorageOptimizerPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None, description='The Catalog ID of the table.'
    )
    DatabaseName: constr(min_length=1, max_length=255) = Field(
        ..., description='Name of the database where the table is present.'
    )
    StorageOptimizerConfig_1: Dict[str, StorageOptimizerConfig] = Field(
        ...,
        alias='StorageOptimizerConfig',
        description='Name of the table for which to enable the storage optimizer.',
    )
    TableName: constr(min_length=1, max_length=255) = Field(
        ..., description='Name of the table for which to enable the storage optimizer.'
    )


class ColumnLFTag(BaseModel):
    LFTags: Optional[LFTagsList] = None
    Name: Optional[NameString] = None


class ColumnLFTagsList(RootModel[List[ColumnLFTag]]):
    root: List[ColumnLFTag]


class CreateDataCellsFilterRequest(BaseModel):
    TableData: DataCellsFilter


class DatabaseLFTagsList(RootModel[List[TaggedDatabase]]):
    root: List[TaggedDatabase]


class DescribeTransactionResponse(BaseModel):
    TransactionDescription_1: Optional[TransactionDescription] = Field(
        None, alias='TransactionDescription'
    )


class Expression(RootModel[List[LFTag]]):
    root: List[LFTag]


class GetDataLakeSettingsResponse(BaseModel):
    DataLakeSettings_1: Optional[DataLakeSettings] = Field(
        None, alias='DataLakeSettings'
    )


class GetResourceLFTagsResponse(BaseModel):
    LFTagOnDatabase: Optional[LFTagsList] = None
    LFTagsOnColumns: Optional[ColumnLFTagsList] = None
    LFTagsOnTable: Optional[LFTagsList] = None


class GetTemporaryGluePartitionCredentialsRequest(BaseModel):
    AuditContext_1: Optional[AuditContext] = Field(None, alias='AuditContext')
    DurationSeconds: Optional[CredentialTimeoutDurationSecondInteger] = None
    Partition: PartitionValueList
    Permissions: Optional[PermissionList] = None
    SupportedPermissionTypes: PermissionTypeList
    TableArn: ResourceArnString


class GetWorkUnitsResponse(BaseModel):
    NextToken: Optional[Token] = None
    QueryId: QueryIdString
    WorkUnitRanges: WorkUnitRangeList


class LFTagError(BaseModel):
    Error: Optional[ErrorDetail] = None
    LFTag: Optional[LFTagPair] = None


class LFTagErrors(RootModel[List[LFTagError]]):
    root: List[LFTagError]


class LFTagPolicyResource(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    Expression_1: Expression = Field(..., alias='Expression')
    ResourceType_1: ResourceType = Field(..., alias='ResourceType')


class ListDataCellsFilterRequest(BaseModel):
    MaxResults: Optional[PageSize] = None
    NextToken: Optional[Token] = None
    Table: Optional[TableResource] = None


class ListTransactionsResponse(BaseModel):
    NextToken: Optional[TokenString] = None
    Transactions: Optional[TransactionDescriptionList] = None


class PartitionObjects(BaseModel):
    Objects: Optional[TableObjectList] = None
    PartitionValues: Optional[PartitionValuesList] = None


class PartitionedTableObjectsList(RootModel[List[PartitionObjects]]):
    root: List[PartitionObjects]


class PutDataLakeSettingsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    DataLakeSettings_1: DataLakeSettings = Field(..., alias='DataLakeSettings')


class RemoveLFTagsFromResourceResponse(BaseModel):
    Failures: Optional[LFTagErrors] = None


class Resource(BaseModel):
    Catalog: Optional[CatalogResource] = None
    DataCellsFilter: Optional[DataCellsFilterResource] = None
    DataLocation: Optional[DataLocationResource] = None
    Database: Optional[DatabaseResource] = None
    LFTag: Optional[LFTagKeyResource] = None
    LFTagPolicy: Optional[LFTagPolicyResource] = None
    Table: Optional[TableResource] = None
    TableWithColumns: Optional[TableWithColumnsResource] = None


class RevokePermissionsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    Permissions: PermissionList
    PermissionsWithGrantOption: Optional[PermissionList] = None
    Principal: DataLakePrincipal
    Resource_1: Resource = Field(..., alias='Resource')


class SearchDatabasesByLFTagsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    Expression_1: Expression = Field(..., alias='Expression')
    MaxResults: Optional[SearchPageSize] = None
    NextToken: Optional[Token] = None


class SearchDatabasesByLFTagsResponse(BaseModel):
    DatabaseList: Optional[DatabaseLFTagsList] = None
    NextToken: Optional[Token] = None


class SearchTablesByLFTagsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    Expression_1: Expression = Field(..., alias='Expression')
    MaxResults: Optional[SearchPageSize] = None
    NextToken: Optional[Token] = None


class StorageOptimizer(BaseModel):
    Config: Optional[StorageOptimizerConfig] = None
    ErrorMessage: Optional[MessageString] = None
    LastRunDetails: Optional[MessageString] = None
    StorageOptimizerType: Optional[OptimizerType] = None
    Warnings: Optional[MessageString] = None


class StorageOptimizerList(RootModel[List[StorageOptimizer]]):
    root: List[StorageOptimizer]


class TaggedTable(BaseModel):
    LFTagOnDatabase: Optional[LFTagsList] = None
    LFTagsOnColumns: Optional[ColumnLFTagsList] = None
    LFTagsOnTable: Optional[LFTagsList] = None
    Table: Optional[TableResource] = None


class UpdateTableObjectsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    DatabaseName: NameString
    TableName: NameString
    TransactionId: Optional[TransactionIdString] = None
    WriteOperations: WriteOperationList


class AddLFTagsToResourcePostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    LFTags: List[LFTagPair] = Field(
        ...,
        description='The LF-tags to attach to the resource.',
        max_length=50,
        min_length=1,
    )
    Resource_1: Resource = Field(
        ..., alias='Resource', description='A structure for the resource.'
    )


class GetResourceLFTagsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    Resource_1: Resource = Field(
        ..., alias='Resource', description='A structure for the resource.'
    )
    ShowAssignedLFTags: Optional[bool] = Field(
        None, description='Indicates whether to show the assigned LF-tags.'
    )


class GrantPermissionsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    Permissions: List[Permission] = Field(
        ...,
        description='The permissions granted to the principal on the resource. Lake Formation defines privileges to grant and revoke access to metadata in the Data Catalog and data organized in underlying data storage such as Amazon S3. Lake Formation requires that each principal be authorized to perform a specific task on Lake Formation resources. ',
    )
    PermissionsWithGrantOption: Optional[List[Permission]] = Field(
        None,
        description='Indicates a list of the granted permissions that the principal may pass to other users. These permissions may only be a subset of the permissions granted in the <code>Privileges</code>.',
    )
    Principal_1: Principal = Field(
        ...,
        alias='Principal',
        description='The Lake Formation principal. Supported principals are IAM users or IAM roles.',
    )
    Resource_1: Resource = Field(
        ..., alias='Resource', description='A structure for the resource.'
    )


class ListPermissionsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    IncludeRelated: Optional[constr(min_length=1, max_length=5)] = Field(
        None,
        description='Indicates that related permissions should be included in the results.',
    )
    MaxResults: Optional[conint(ge=1, le=1000)] = Field(
        None, description='The maximum number of results to return.'
    )
    NextToken: Optional[str] = Field(
        None,
        description='A continuation token, if this is not the first call to retrieve this list.',
    )
    Principal_1: Optional[Principal] = Field(
        None,
        alias='Principal',
        description='The Lake Formation principal. Supported principals are IAM users or IAM roles.',
    )
    Resource_1: Optional[Resource] = Field(
        None, alias='Resource', description='A structure for the resource.'
    )
    ResourceType: Optional[ResourceType1] = Field(
        None,
        description='Specifies a resource type to filter the permissions returned.',
    )


class RemoveLFTagsFromResourcePostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    LFTags: List[LFTagPair] = Field(
        ...,
        description='The LF-tags to be removed from the resource.',
        max_length=50,
        min_length=1,
    )
    Resource_1: Resource = Field(
        ..., alias='Resource', description='A structure for the resource.'
    )


class RevokePermissionsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    Permissions: List[Permission] = Field(
        ...,
        description='The permissions revoked to the principal on the resource. For information about permissions, see <a href="https://docs.aws.amazon.com/lake-formation/latest/dg/security-data-access.html">Security and Access Control to Metadata and Data</a>.',
    )
    PermissionsWithGrantOption: Optional[List[Permission]] = Field(
        None,
        description='Indicates a list of permissions for which to revoke the grant option allowing the principal to pass permissions to other principals.',
    )
    Principal_1: Principal = Field(
        ...,
        alias='Principal',
        description='The Lake Formation principal. Supported principals are IAM users or IAM roles.',
    )
    Resource_1: Resource = Field(
        ..., alias='Resource', description='A structure for the resource.'
    )


class AddLFTagsToResourceRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    LFTags: LFTagsList
    Resource_1: Resource = Field(..., alias='Resource')


class AddLFTagsToResourceResponse(BaseModel):
    Failures: Optional[LFTagErrors] = None


class BatchPermissionsRequestEntry(BaseModel):
    Id: Identifier
    Permissions: Optional[PermissionList] = None
    PermissionsWithGrantOption: Optional[PermissionList] = None
    Principal: Optional[DataLakePrincipal] = None
    Resource_1: Optional[Resource] = Field(None, alias='Resource')


class BatchPermissionsRequestEntryList(RootModel[List[BatchPermissionsRequestEntry]]):
    root: List[BatchPermissionsRequestEntry]


class BatchRevokePermissionsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    Entries: BatchPermissionsRequestEntryList


class GetResourceLFTagsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    Resource_1: Resource = Field(..., alias='Resource')
    ShowAssignedLFTags: Optional[BooleanNullable] = None


class GetTableObjectsResponse(BaseModel):
    NextToken: Optional[TokenString] = None
    Objects: Optional[PartitionedTableObjectsList] = None


class GrantPermissionsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    Permissions: PermissionList
    PermissionsWithGrantOption: Optional[PermissionList] = None
    Principal: DataLakePrincipal
    Resource_1: Resource = Field(..., alias='Resource')


class ListPermissionsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    IncludeRelated: Optional[TrueFalseString] = None
    MaxResults: Optional[PageSize] = None
    NextToken: Optional[Token] = None
    Principal: Optional[DataLakePrincipal] = None
    Resource_1: Optional[Resource] = Field(None, alias='Resource')
    ResourceType: Optional[DataLakeResourceType] = None


class ListTableStorageOptimizersResponse(BaseModel):
    NextToken: Optional[Token] = None
    StorageOptimizerList_1: Optional[StorageOptimizerList] = Field(
        None, alias='StorageOptimizerList'
    )


class PrincipalResourcePermissions(BaseModel):
    AdditionalDetails: Optional[DetailsMap] = None
    Permissions: Optional[PermissionList] = None
    PermissionsWithGrantOption: Optional[PermissionList] = None
    Principal: Optional[DataLakePrincipal] = None
    Resource_1: Optional[Resource] = Field(None, alias='Resource')


class PrincipalResourcePermissionsList(RootModel[List[PrincipalResourcePermissions]]):
    root: List[PrincipalResourcePermissions]


class RemoveLFTagsFromResourceRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    LFTags: LFTagsList
    Resource_1: Resource = Field(..., alias='Resource')


class TableLFTagsList(RootModel[List[TaggedTable]]):
    root: List[TaggedTable]


class BatchGrantPermissionsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    Entries: List[BatchPermissionsRequestEntry] = Field(
        ...,
        description='A list of up to 20 entries for resource permissions to be granted by batch operation to the principal.',
    )


class BatchRevokePermissionsPostRequest(BaseModel):
    CatalogId: Optional[constr(min_length=1, max_length=255)] = Field(
        None,
        description='The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment. ',
    )
    Entries: List[BatchPermissionsRequestEntry] = Field(
        ...,
        description='A list of up to 20 entries for resource permissions to be revoked by batch operation to the principal.',
    )


class BatchGrantPermissionsRequest(BaseModel):
    CatalogId: Optional[CatalogIdString] = None
    Entries: BatchPermissionsRequestEntryList


class BatchPermissionsFailureEntry(BaseModel):
    Error: Optional[ErrorDetail] = None
    RequestEntry: Optional[BatchPermissionsRequestEntry] = None


class BatchPermissionsFailureList(RootModel[List[BatchPermissionsFailureEntry]]):
    root: List[BatchPermissionsFailureEntry]


class BatchRevokePermissionsResponse(BaseModel):
    Failures: Optional[BatchPermissionsFailureList] = None


class GetEffectivePermissionsForPathResponse(BaseModel):
    NextToken: Optional[Token] = None
    Permissions: Optional[PrincipalResourcePermissionsList] = None


class ListPermissionsResponse(BaseModel):
    NextToken: Optional[Token] = None
    PrincipalResourcePermissions: Optional[PrincipalResourcePermissionsList] = None


class SearchTablesByLFTagsResponse(BaseModel):
    NextToken: Optional[Token] = None
    TableList: Optional[TableLFTagsList] = None


class BatchGrantPermissionsResponse(BaseModel):
    Failures: Optional[BatchPermissionsFailureList] = None
